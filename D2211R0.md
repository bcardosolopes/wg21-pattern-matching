---
title: "Exhaustiveness Checking for Pattern Matching"
document: D2211R0
date: 2019-08-07
audience: Evolution
author:
  - name: Bruno Cardoso
    email: <bruno.cardoso@gmail.com>
  - name: Sergei Murzin
    email: <smurzin@bloomberg.net>
  - name: Michael Park
    email: <mcypark@gmail.com>
  - name: David Sankel
    email: <dsankel@bloomberg.net>
  - name: Dan Sarginson
    email: <dsarginson@bloomberg.net>
  - name: Bjarne Stroustrup
    email: <bjarne@stroustrup.com>
toc: true
toc-depth: 4
---

# Abstract

With the introduction of Pattern Matching into C++, there's an opportunity to
give it support for "exhaustiveness checking" which enables compile-time
detection and diagnosis of several common Pattern Matching bugs. This paper
describes the design for such a feature that intentionally caters to typical
software engineering patterns and commonly understood semantics, as opposed to
a pedantic interpretation of code. It is our hope that such a design will
maximize this feature's utility as a bug prevention mechanism.

```C++
enum Color { Red, Green, Blue };
//...
Color c = /*...*/;
vec3 v = inspect(c) {                 // ERROR: Missing case 'Blue'
  case Red   => vec3(1.0, 0.0, 0.0),
  case Green => vec3(0.0, 1.0, 0.0),
};

vec3 v2 = inspect(c) {                // OKAY
  case Red   => vec3(1.0, 0.0, 0.0),
  case Green => vec3(0.0, 1.0, 0.0),
  case Blue  => vec3(0.0, 0.0, 1.0),
};
```

# Introduction

This paper describes a mechanism that allows for compilation errors for `inspect`
expressions that that aren't exhaustive, i.e. none of the patterns match a
particular value. Prior to this proposal, the best a compiler could do in such
a situation is produce a warning and, if unheeded, undefined behavior would
result at runtime.

The "Examples" section of this paper builds up our proposed semantics using a
series of code snippets. It is our intent that this section be widely
understandable by those already familiar with [@P1371R2]. It is a followed by a
"Specification" section that includes a formal treatment of the semantics.
Remaining sections consider some special cases and alternatives.

In all our examples, we utilize the pattern matching syntax specified in
[@P1371R2] for expressions. While it is known that several syntax changes will
be made in the next revision of that paper, none of those changes will
influence the exhaustiveness checking algorithm.

# Examples

This section presents our proposed exhaustiveness checking semantics by
building on a series of easily-understood examples. The subsequent
"Specification" section provides a formal and complete, albeit terse,
treatment.

## Exhaustive Patterns

TODO: wildcard and identifiers. Touch on structured bindings, but note we'll
get back to this later.

```C++
inspect(i) {
  1  => std::cout << "one",
  2  => std::cout << "two",
  __ => std::cout << "something else",
}
```

```C++
inspect(i) {
  1 => std::cout << "one",
  2 => std::cout << "two",
  x => std::cout << x,
}
```

```C++
struct Point { int xCoordinate; int yCoordinate; }

struct Box { Point topLeft; int width; int height };

inspect(box) {
  [tl, w, h] => /*...*/,
  [[x,y], w, h] => /*...*/
}
```

## Fundamental Types

TODO: two categories, those that require an arm with exhaustive patterns, and
those that do not.

```c++
bool b = /*...*/;
char const * const str = inspect(b) { true => "true" }; // ERROR: missing
                                                        // false pattern
```

```c++
bool b = /*...*/;
char const * const str = inspect(b) {
  true => "true",
  false => "false"                    // OKAY, pattern exhaustive
};

char const * const str = inspect(b) {
  true => "true",
  __   => "false"                     // OKAY, pattern exhaustive
};
```

## `enum`

```C++
enum Color { Red, Green, Blue };
//...
Color c = /*...*/;
vec3 v = inspect(c) {                 // ERROR: Missing case 'Blue'
  case Red   => vec3(1.0, 0.0, 0.0),
  case Green => vec3(0.0, 1.0, 0.0),
};
```

```C++
vec3 v = inspect(c) {                // OKAY
  case Red   => vec3(1.0, 0.0, 0.0),
  case Green => vec3(0.0, 1.0, 0.0),
  case Blue  => vec3(0.0, 0.0, 1.0),
};
```

```C++
Color val_outside_enumerators = static_cast<Color>(3);

vec3 v = inspect(val_outside_enumerators) {     // 'std::terminate' at runtime
  case Red   => vec3(1.0, 0.0, 0.0),
  case Green => vec3(0.0, 1.0, 0.0),
  case Blue  => vec3(0.0, 0.0, 1.0),
};
```

```C++
Color val_outside_enumerators = static_cast<Color>(3);

vec3 v = inspect(val_outside_enumerators) {     // Throw exception at runtime
  case Red   => vec3(1.0, 0.0, 0.0),
  case Green => vec3(0.0, 1.0, 0.0),
  case Blue  => vec3(0.0, 0.0, 1.0),
  __         => throw Up{},
};
```

Note that any desired behavior here is configurable.

## Classes and `tuple`-like Types

TODO: Class examples and deep derived equality

```C++
struct FlagsV1 {
  bool firstFlag;
  bool secondFlag;
};
```

```C++
inspect(flagsV1) {
  [false, false] => /*...*/,
  [true , false] => /*...*/,
  [_    , true ] => /*...*/,
};
```

```C++
struct FlagsV2 {
  bool firstFlag;
  bool secondFlag;

  bool operator==(const FlagsV2&) const = default;
};
```

```C++
constexpr auto allFalse = FlagsV2{ .firstFlag=false,
                                   .secondFlag=false };
inspect(flagsV2) {
  case allFalse  => /*...*/,
  [false, false] => /*...*/,
  [_    , true ] => /*...*/,
};
```

```C++
struct FlagsV3 {
  bool firstFlag;
  bool secondFlag;

  bool operator==(const FlagsV3& other) const {
    return firstFlag  == other.firstFlag &&
           secondFlag == other.secondFlag;
  };
};
```

```C++
constexpr auto allFalse = FlagsV3{ .firstFlag=false,
                                   .secondFlag=false };
inspect(flagsV3) {
  case allFalse  => /*...*/,
  [false, false] => /*...*/,
  [_    , true ] => /*...*/,  // ERROR: {false, false} case not handled.
};
```

## `variant`-like Types

```c++
struct FireBlasters{
  int intensity;
  bool operator==(const FireBlasters&) const = default;
};

enum Direction{ Left, Right };

struct Move{
  Direction direction;
  bool operator==(const FireBlasters&) const = default;
};

using Command = std::variant<FireBlasters, Move>;
```

```c++
std::string cmdToStringV1(Command cmd) {
  return inspect(cmd) {
    <FireBlasters> [i] => std::format("Fire Blasters with power {}", i),
    <Move> [case Left] => std::string("Move Left"),

    // ERROR: No coverage for '<Move> [Right]' value.
  };
}
```

```c++
std::string cmdToStringV2(Command cmd) {
  return inspect(cmd) { // OK
    <FireBlasters> [i]  => std::format("Fire Blasters with power {}", i),
    <Move> [case Left]  => std::string("Move Left"),
    <Move> [case Right] => std::string("Move Right"),
  };
}
```

```c++
Command pathological = /*...*/; // Somehow put pathological in the
                                // 'valueless_by_exception' state.

auto s = cmdToStringV2(pathological); // throws 'std::bad_variant_access'
```

```c++
std::string cmdToStringV3(Command cmd) {
  return inspect(cmd) {
    <FireBlasters> [i]  => std::format("Fire Blasters with power {}", i),
    <Move> [case Left]  => std::string("Move Left"),
    <Move> [case Right] => std::string("Move Right"),
    __ => std::string("Pathological Command"),
  };
}

//...
auto s = cmdToStringV3(pathological); // Assign 's' to "Pathological Command"
```

Note that this mimics `enum` behavior.

## Special Cases

### Class Hierarchy Matching

```c++
struct CommandV2 {
  virtual ~Command() = default;
};

struct FireBlastersV2 : CommandV2 {
  int intensity;
};

struct MoveV2 : CommandV2 {
  Direction direction;
};
```

```c++
std::string cmdToStringV5(CommandV2 cmd) {
  return inspect(cmd) {
    <FireBlasters> [i]  => std::format("Fire Blasters with power {}", i),
    <Move> [case Left]  => std::string("Move Left"),
    <Move> [case Right] => std::string("Move Right"),

    // ERROR, exhaustive pattern required
  };
}
```

```c++
std::string cmdToStringV5(CommandV2 cmd) {
  return inspect(cmd) { // OK
    <FireBlasters> [i]  => std::format("Fire Blasters with power {}", i),
    <Move> [case Left]  => std::string("Move Left"),
    <Move> [case Right] => std::string("Move Right"),
    __                  => std::string("Unknown"),
  };
}
```

### Pattern Guards

```c++
int fib(int n) {
  return inspect(n) {          // ERROR: Patterns not exhaustive
    0             => 0,
    1             => 1,
    n if (n >= 1) => fib(n-1) + fib(n-2),
    n if (n < 0)  => throw std::invalid_argument("fib called with negative"),
  };
}
```

```c++
int fib(int n) {
  return inspect(n) {          // OK
    0             => 0,
    1             => 1,
    n if (n >= 1) => fib(n-1) + fib(n-2),
    __            => throw std::invalid_argument("fib called with negative"),
  };
}
```

### Dereference Extractors

```c++
struct BinaryTree;
struct Node { int value; };
struct Branch {
  std::unique_ptr<BinaryTree> left;
  std::unique_ptr<BinaryTree> right;
};
struct BinaryTree : std::variant<Node, Branch> {
  using std::variant<Node, Branch>;
};
```

```c++
bool depthTwo(const BinaryTree & t) {
  return inspect(t) {             // ERROR: Patterns not exhaustive
    <Node> __                                 => false,
    <Branch> [(*?) <Branch> __, __]           => true,
    <Branch> [__, (*?) <Branch> __]           => true,
    <Branch> [(*?) <Node> __, (*?) <Node> __] => false,
    <Branch> [nullptr, nullptr]               => false,
  };
}
```

```c++
bool depthTwo(const BinaryTree & t) {
  return inspect(t) {             // OK
    <Node> __ => false,
    <Branch> [(*?) <Branch> __, __]           => true,
    <Branch> [__, (*?) <Branch> __]           => true,
    <Branch> [(*?) <Node> __, (*?) <Node> __] => false,
    <Branch> __                               => false,
  };
}
```

Note the missing `nullptr` handling in the following example.

```c++
bool depthTwo(const BinaryTree & t) {
  return inspect(t) {             // OK
    <Node> __ => false,
    <Branch> [(*!) <Branch> __, __]           => true,
    <Branch> [__, (*!) <Branch> __]           => true,
    <Branch> [(*!) <Node> __, (*!) <Node> __] => false,
  };
}
```

Our Preferred implementation

```c++
bool depthTwo(const BinaryTree & t) {
  return inspect(t) {
    <Node>   __                               => false,
    <Branch> [(*!) <Node> __, (*!) <Node> __] => false,
    __                                        => true,
  };
}
```

### General Extractors

```c++
int val = inspect(str) {     //ERROR: Non-exhaustive
  (regex_pat<"(\\d+)"> ?) [digits] => std::atoi(digits),
  (regex_pat<".*"> ?)     __       => -1,
}
```

```c++
int val = inspect(str) {     //OK
  (regex_pat<"(\\d+)"> ?) [digits] => std::atoi(digits),
  __                               => -1,
}
```

# Specification

For an expression `e` of type `T`, any `inspect` expression,

```c++
inspect(e) {
  /case₁/ => code₁  // arm₁
  /case₂/ => code₂  // arm₂
         ⋮
  /caseₙ/ => codeₙ  // armₙ
}
```

, must, for every *q*-value (*qᵢ*) of `T`, include an case (caseⱼ) that
*q*-matches that *q*-value (*q*-match(*qᵢ*, caseⱼ) = `true`). *q*-values are
defined on a per-type basis and the *q*-match function is defined on a
per-pattern basis.

## *q*-match and guards

Arms with guards do not contribute to compile-time exhaustiveness checking due
to their runtime semantics. Therefore, we have the following rule:

- *q*-match( *v*, `pat` *inspect-guard*) is `false` for every *q*-value
  *v* and pattern `pat`.

## *q*-values for fundamental types

- `std::nullptr_t` is defined to have a single *q*-value, `nullptr`.
- `bool` is defined to have two *q*-values, `true`, and `false`.
- The remaining fundamental types are defined to each have a single *q*-value
  *ε*.

## *q*-match for fundamental types

Three patterns apply to fundamental types: wildcards (*wildcard-pattern*),
bindings (*binding-pattern*), and expressions (*expression-pattern*).

Wildcards and bindings, unsurprisingly, match any *q*-value.

- *q*-match( *v*, *wildcard-pattern* ) is `true` for every *q*-value *v*
- *q*-match( *v*, *binding-pattern* ) is `true` for every *q*-value *v*

Expression patterns *q*-match only when the expression evaluates to the
particular *q*-value.

- *q*-match( *v*, *expression-pattern* ) is `true` if the expression pattern
  evaluates to *q*-value *v* and `false` otherwise.

Note that because expression patterns cannot evaluate to ε, *q*-match( ε,
*expression-pattern* ) is always `false`.

## Classes

Classes without data members have a single *q*-value `{}` and we have the
following rules:

- *q*-match( `{}`, *wildcard-pattern* ) is `true`
- *q*-match( `{}`, *binding-pattern* ) is `true`
- *q*-match( `{}`, *expression-pattern* ) is `true`
- *q*-match( `{}`, `[]` ) is `true`

Classes with data members have *q*-values based on their fields. These *q*-values
are of the form `{` *v₁*, *v₂*, …, *vₙ* `}` where *vᵢ* ranges over the
*q*-values of the *i*th data member of the class. The following *q*-match rules
apply:

- *q*-match( `{` *v₁*, *v₂*, …, *vₙ* `}`, *wildcard-pattern* ) is `true`
- *q*-match( `{` *v₁*, *v₂*, …, *vₙ* `}`, *binding-pattern* ) is `true`
- *q*-match( `{` *v₁*, *v₂*, …, *vₙ* `}`, `[` pat₁, pat₂, …, patₙ `]` ) is
  `true` if *q*-match(*vᵢ*, patᵢ)=`true` for every *i*, and `false` otherwise.

Expression patterns *q*-match classes only if the class type is said to have
*deep derived equality*.

- *q*-match( `{` *v₁*, *v₂*, …, *vₙ* `}`, *expression-pattern* ) is `true` if
  `{` *v₁*, *v₂*, …, *vₙ* `}` has the same value as the *expression-pattern*
  and the class being matched has *deep derived equality*.

A class `C` has *deep derived equality* if the following conditions are met:

1. `C` has a defaulted `operator==`.
2. All of `C`'s fields are `std::nullptr_t`, `bool`, or are classes having *deep
   derived equality*.

Finally, classes that are polymorphic have the additional *q*-match rule:

- *q*-match( *v*, < *type* > *pattern* ) is `false`

## Tuple-like types

Tuple-like types are those that opt-in to structured binding syntax by
specializing `std::tuple_size`, `std::get`, and `std::tuple_element`. Like
classes, tuple-like types `T` have *q*-values of the form `{` *v₁*, *v₂*, …,
*vₙ* `}`, but where *vᵢ* ranges over the *q*-values of
`std::tuple_element<`*i*`, T>::type`.

The *q*-match rules are identical to those with classes except
*q*-match always returns false for *expression-patterns*.

- *q*-match( `{` *v₁*, *v₂*, …, *vₙ* `}`, *expression-pattern* ) is `false` if
  the class being matched is a tuple-like type.

## Variant-like types

Variant-like types are those that opt-in to pattern matching syntax by
specializing `std::variant_size`, `std::holds_alternative`, `std::get`, and
`std::variant_alternative`.  *q*-values of variant-like types `V` are of the
form (*i*, *v*) where 0 <= *i* < `std::variant_size<V>::value` and *v* ranges
over the *q*-values of `std::variant_alternative<`*i*`, V>::type`.

Our matching rules are as follows:

- *q*-match( (*i*, *v*), *wildcard-pattern* ) is `true`
- *q*-match( (*i*, *v*), *binding-pattern* ) is `true`
- *q*-match( (*i*, *v*), *expression-pattern* ) where *epat* is an
  *expression-pattern* is `true` if and only if

  1. the expression evaluates to a value *w* where
     `std::holds_alternative<`*i*`>(`*w*`) = true`,
  2. *q*-match( *v*, `std::get<`*i*`>(`*w*`)` ) = `true`,
  3. the `std::holds_alternative<`*i*`>` specialization is `constexpr`, and
  4. the `std::get<`*i*`>` specialization is `constexpr`.
- *q*-match( (*i*, *v*), < auto > *pat* ) is `true` if and only if *q*-match(
  *v*, *pat* ) is true.
- *q*-match( (*i*, *v*), < *concept* > *pat* ) is `true` if and only if
  `std::variant_alternative<i,V>::type` satisfies the concept and *q*-match(
  *v*, *pat* ) is true.
- *q*-match( (*i*, *v*), < *type* > *pat* ) is `true` if and only if
  `std::variant_alternative<i,V>::type` is the same as *type* and *q*-match(
  *v*, *pat* ) is true.
- *q*-match( (*i*, *v*), < *constant-expression* > *pat* ) is `true` if and
  only if the expression evaluates to *i* and *q*-match( *v*, *pat* ) is true.

## Any-like types

Any-like types are those that opt-in to pattern matching syntax by specializing
the `any_cast` function template. All such types `A` have a single *q*-value ε
with the following *q*-match rules.

- *q*-match( ε, *wildcard-pattern* ) is `true`
- *q*-match( ε, *binding-pattern* ) is `true`
- *q*-match( ε, *expression-pattern* ) is `false`
- *q*-match( ε, < *type* > *pattern* ) is `false`

## Pointer-like types

TBD

## Extractor patterns

TBD

# Patterns for Invariant Checking

Suppress arm contribution to exhaustiveness checking

TODO: give strange example I sent out in an email and cover it.

Consider this example program:

```c++
enum Color{ RED, GREEN, BLUE };

int main() {
  // Assuming an 'enumerators' reflection facility
  std::for_each(enumerators<Color>(), [](Color c) {
    std::cout << int(c) << " = "
      << inspect(c){ case RED   : "Red";
                     case GREEN : "Green";
                     case BLUE  : "Blue";
                   }
      << std::endl;
  });
  std::cout << "\nSelect a color: " << std::flush;
  Color c;
  std::cin >> c;

  inspect(c) {
    case RED   : std::cout << "(1,0,0)" << std::endl;
    case GREEN : std::cout << "(0,1,0)" << std::endl;
    __ : std::cerr << "Bad selection!" << std::endl;
  };
}
```

Note that the second inspect statement has a bug: the BLUE case isn't handled.
Our exhaustiveness checking algorithm will not catch this case because of the
presence of the wildcard arm.

There is desire to annotate the wildcard arm to somehow indicate that it is an
error handling arm and should not impact exhaustiveness checking.

One way to do this is to add a guard since the presence of a guard excludes an
arm from exhaustiveness checking. The following code will produce a compilation
error as desired, indicating the missing 'BLUE' case:

```c++
// OPTION 1

inspect(c) {
  case RED   : std::cout << "(1,0,0)" << std::endl;
  case GREEN : std::cout << "(0,1,0)" << std::endl;
  __ if(true) : std::cerr << "Bad selection!" << std::endl;
};
```

While this works, the syntax we use 'if(true)' doesn't capture the intent very
well. If we want special syntax cheaply we could allow the condition in the
guard to be empty:

```c++
// OPTION 2

inspect(c) {
  case RED   : std::cout << "(1,0,0)" << std::endl;
  case GREEN : std::cout << "(0,1,0)" << std::endl;
  __ if() : std::cerr << "Bad selection!" << std::endl;
};
```

Or we could use some kind of context-sensitive keyword (or annotation) to more
directly indicate this is an exceptional case:

```c++
// OPTION 3

inspect(c) {
  case RED   : std::cout << "(1,0,0)" << std::endl;
  case GREEN : std::cout << "(0,1,0)" << std::endl;
  __ exceptional : std::cerr << "Bad selection!" << std::endl;
};
```

I'm leaning towards option 1 for core pattern matching. It demonstrates that we
do not need special syntax or additional complexity to handle this use case
right now and, at least to me, it isn't clear that this use case will be a
prevalent one. Options 2 and 3 are things that could added later on if we see
that the use case is more widespread.

# Analysis of alternatives

- Mention that this is something other languages use.

## Use warnings instead of errors

## Require pedantically exhaustive `enum` inspection

# Conclusion
